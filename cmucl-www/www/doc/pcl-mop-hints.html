@@DTD@@
<html>
<head>
<title>CMUCL: Hints for using the PCL MOP</title>
@@METAS@@
</head>

<body bgColor="#FFFFFF" text="#000000">

@@HEADING(Hints for using the PCL Metaobject Protocol)

<p> The CLOS <strong>Metaobject Protocol</strong> (MOP) is a
    semi-standardized reflective extension to CLOS. Most Common Lisp
    implementations (including CMUCL) implement a metaobject protocol that
    is similar to the specification given in <a href =
    "http://www.lisp.org/mop/">chapters 5 and 6 of the <i>The Art of the
    MetaObject Protocol</i></a> (a book whose title is often abbreviated
    <i>AMOP</i>). However, the PCL MOP provided by CMUCL has a few
    differences from AMOP, and behaves differently from the MOP in other
    Common Lisp implementations in certain respects.

<p> The major issues that can arise are:

<ul>
<li> Make sure that you use symbols from the right package. A number of
     symbols, such as <tt class=code>STANDARD-CLASS</tt> exist both in the
     <tt class=code>COMMON-LISP</tt> package and in the <tt
     class=code>PCL</tt> package. For MOP programming you should be using
     the symbols from the PCL package.

<li> CMUCL has a package named <tt class=code>MOP</tt>, which exports most
     (but not all) of the symbols defined in AMOP.

<li> Since CMUCL uses special wrappers around class-objects, you sometimes
     need to use <tt class="function-name">PCL::COERCE-TO-PCL-CLASS</tt> to
     coerce the wrapper objects into real MOP-aware objects. For example,
     this occurs when using the <tt class="function-name">CLASS-OF</tt>
     function. 

<li> You may need to define methods on <tt class =
     "function-name">PCL:VALIDATE-SUPERCLASS</tt> more often than is said
     in AMOP. For example, consider a class called <tt>FOO</tt> whose
     metaclass is <tt>META-FOO</tt>. Class FOO inherits from class T, whose
     metaclass is <tt>STANDARD-CLASS</tt>, and in the PCL MOP you have to
     declare that this combination of metaclasses is valid:

<pre class=code>
   (defmethod pcl:validate-superclass ((class meta-foo) (super pcl::standard-class))
      t)
</pre>
</ul>


<h2>Details on the class schizophrenia</h2>

<p> PCL, the CLOS implementation that is used in CMUCL, is integrated with
    the rest of CMUCL in a somewhat incomplete way. The type system of PCL
    and of the CMUCL kernel have different notions of what a class is. This
    is because classes are fundamental to the CMUCL type system, yet CMUCL
    needs to be able to function without PCL loaded (mainly in order to be
    able to build itself). The way that this problem is resolved is by
    having the CMUCL kernel maintain parallel class hierarchies. For
    instance, <tt class=code>LISP:CLASS</tt> and <tt
    class=code>PCL:CLASS</tt> are different types. The function <tt
    class="function-name">LISP:FIND-CLASS</tt> returns instances of <tt
    class=code>LISP:CLASS</tt>, whereas the function <tt
    class="function-name">PCL:FIND-CLASS</tt> returns <tt
    class=code>PCL:CLASS</tt> instances. For example

<pre class=code>
   USER&gt; (lisp:find-class 'cons)
   #&lt;built-in-class cons (sealed) {28073C8D}&gt;
   USER&gt; (pcl:find-class 'cons)
   #&lt;Built-In-Class cons {2817967D}&gt;
</pre>

<p> These two classes are in one sense the same class, in that they
    represent the same type: CONS. However, PCL has its own way of
    representing that type internally. 

<p> In order to make this situation livable, PCL has been hacked up to
    accept <tt class=code>LISP:CLASS</tt> objects in the common places
    where people supply classes to PCL operations. You can also explicitly
    convert between the two kinds of classes, either by using the class
    name and the appropriate <tt class="function-name">FIND-CLASS</tt>, or
    by:

<pre class=code>
    (kernel:class-pcl-class lisp-class)  ==&gt; the PCL class
    (kernel:layout-class (pcl::class-wrapper pcl-class))  ==&gt; the LISP class
</pre>

<p> Another problem area is with generic functions that are called by PCL
with classes as arguments. These classes will be <tt
class=code>PCL:CLASS</tt>es, so if you try to specialize on e.g. <tt
class="function-name">ALLOCATE-INSTANCE</tt> using an <tt
class="function-name">EQL</tt> specializer, then make sure the class in the
specializer is a <tt class=code>PCL:CLASS</tt>.

<p> People who stick to using standard CLOS operations shouldn't ever
notice all this smoke and mirrors. People using standard CLOS operations
shouldn't have their packages use the PCL package, since the Common-Lisp
package exports a consistent set of definitions for standard CLOS
operations.

<p> Though the above hacks usually work for simple stuff, they often seem to
break down when defining new metaclasses.  What you need to do is explictly
specify the <tt class=code>PCL::</tt> prefix on the class name.


@@FOOTER@@
</body>
</html>
