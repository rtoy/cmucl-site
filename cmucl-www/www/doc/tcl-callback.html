@@DTD@@
<html>
<head>
<title>Callbacks from tcl to CMUCL</title>
@@METAS@@
</head>

<body bgColor="#FFFFFF" text="#000000">

@@HEADING(Callbacks from Tcl to CMUCL)

<p> This page describes how to use the CMUCL FFI to allow callbacks from
foreign code into Lisp. This implementation only works when using the
generational garbage collector (you should have <tt class=code>:gencgc</tt>
in your <tt class=variable>*features*</tt> list; this is the case on all
x86 platforms). It is also possible to make it work with the
non-generational garbage collector; ask the cmucl-help mailing list. There
is some glue code in Lisp to save into cl-tcl.lisp, some C glue code to
save into tcl-callback.c, and some demo code at the end. </p>

<p> The following code should be saved into a file <tt>cl-tcl.lisp</tt>:
</p>

<pre class="code">
;;; Evaluate (alien:load-foreign &quot;/usr/lib/libtcl8.0.so&quot;) and
;;; (alien:load-foreign &quot;tcl-demo.o&quot;) before compiling or loading
;;; this file.  You will also likely need a version of CMUCL where
;;; the /usr/bin/lisp binary has been produced with the flags
;;; -Xlinker --export-dynamic added to OS_LINK_FLAGS in Config.linux*
;;; Note that the Debian binaries usually don't include these flags.

(cl:defpackage &quot;CL-TCL&quot;
    (:use &quot;CL&quot; &quot;ALIEN&quot; &quot;C-CALL&quot; &quot;SYSTEM&quot;)
  (:export
   &quot;+TCL-OK+&quot; &quot;+TCL-ERROR+&quot; &quot;+TCL-RETURN+&quot; &quot;+TCL-BREAK+&quot; &quot;+TCL-CONTINUE+&quot;
   &quot;TCL-INTERPRETER&quot;
   &quot;CREATE-TCL-INTERPRETER&quot; &quot;DESTROY-TCL-INTERPRETER&quot;
   &quot;REGISTER-TCL-COMMAND&quot; &quot;UNREGISTER-TCL-COMMAND&quot;
   &quot;WITH-TCL-INTERPRETER&quot; &quot;EVAL-TCL-EXPR&quot;))

(in-package :CL-TCL)

;;;; User and Implementation-level constants

(defconstant +TCL-OK+ 0
  &quot;TCL return code:  Command completed normally; the interpreter's
result contains the command's result.&quot;)

(defconstant +TCL-ERROR+ 1
  &quot;TCL return code:  The command couldn't be completed successfully;
the interpreter's result describes what went wrong.&quot;)

(defconstant +TCL-RETURN+ 2
  &quot;TCL return code:  The command requests that the current procedure
return; the interpreter's result contains the procedure's return value.&quot;)

(defconstant +TCL-BREAK+ 3
  &quot;TCL return code:  The command requests that the innermost loop
be exited; the interpreter's result is meaningless.&quot;)

(defconstant +TCL-CONTINUE+ 4
  &quot;TCL return code:  Go on to the next iteration of the current loop;
the interpreter's result is meaningless.&quot;)

;;;; FFI bindings to the Tcl Library and the C-side of the callback stuff

(declaim (inline tcl-createinterp))
(def-alien-routine &quot;Tcl_CreateInterp&quot; system-area-pointer)

(declaim (inline tcl-eval))
(def-alien-routine &quot;Tcl_Eval&quot; int
  (interp system-area-pointer :in)
  (string c-string :in))

(declaim (inline tcl-getstringresult))
(def-alien-routine &quot;Tcl_GetStringResult&quot; c-string
  (interp system-area-pointer :in))

(declaim (inline tcl-deleteinterp))
(def-alien-routine &quot;Tcl_DeleteInterp&quot; void
  (interp system-area-pointer :in))

(declaim (inline set-lisp-callback-handler))
(def-alien-routine &quot;Set_Lisp_Callback_Handler&quot; void
  (handler unsigned-long :in))

(declaim (inline register-tcl-lisp-command))
(def-alien-routine &quot;Register_Tcl_Lisp_Command&quot; void
  (interp system-area-pointer :in)
  (name c-string :in))

(declaim (inline unregister-tcl-lisp-command))
(def-alien-routine &quot;Unregister_Tcl_Lisp_Command&quot; void
  (interp system-area-pointer :in)
  (name c-string :in))

;;;; User-level stuff

(defstruct (tcl-interpreter (:print-function print-tcl-interpreter))
  (valid-p t)
  (sap (int-sap 0) :type system-area-pointer)
  (commands (make-hash-table :test #'equal) :read-only t))

(defun print-tcl-interpreter (inter stream depth)
  (declare (ignore depth))
  (print-unreadable-object (inter stream :type t :identity t)
    (format stream &quot;~:[(INVALID)~;(valid@~8,'0X)~]&quot;
	    (tcl-interpreter-valid-p inter)
	    (sap-int (tcl-interpreter-sap inter)))))

(defvar *tcl-interpreter-list* nil
  &quot;List of valid TCL interpreters.&quot;)

(defun create-tcl-interpreter ()
  &quot;Create a TCL interpreter object that can be passed to the other
functions of CL-TCL.&quot;
  (let ((result (make-tcl-interpreter :sap (tcl-createinterp))))
    (push result *tcl-interpreter-list*)
    result))

(defun destroy-tcl-interpreter (inter)
  &quot;Destroy the TCL interpreter object `inter'.&quot;
  (assert (and (tcl-interpreter-valid-p inter)
	       (member inter *tcl-interpreter-list*)))
  (setf *tcl-interpreter-list*
	(delete (tcl-interpreter-sap inter) *tcl-interpreter-list*
		:key #'tcl-interpreter-sap :test #'sap=))
  (tcl-deleteinterp (tcl-interpreter-sap inter))
  (setf (tcl-interpreter-valid-p inter) nil
	(tcl-interpreter-sap inter) (int-sap 0))
  inter)

(defun register-tcl-command (inter name handler)
  &quot;Registers the lisp function `handler' as the handler for the
command named by the string `name' in the TCL-Interpreter `inter'.
Any previously existing handlers will be superseded.  When the
corresponding command is invoked in the TCL interpreter, the handler
will be called with the TCL-Interpreter object, the command name and
all the arguments to the TCL command.  The handler must return two
values: The return code (one of +TCL-OK+, +TCL-ERROR+, +TCL-RETURN+,
+TCL-BREAK+ or +TCL-CONTINUE+) and the result or error indicator
string.&quot;
  (assert (tcl-interpreter-valid-p inter))
  (setf (gethash name (tcl-interpreter-commands inter)) handler)
  (register-tcl-lisp-command (tcl-interpreter-sap inter) name))

(defun unregister-tcl-command (inter name)
  &quot;Unregisters the previously registered command named `name' in the
TCL-Interpreter `inter'.  Returns the old handler function.&quot;
  (assert (tcl-interpreter-valid-p inter))
  (let ((handler (gethash name (tcl-interpreter-commands inter) nil)))
    (assert handler)
    (remhash name (tcl-interpreter-commands inter))
    (unregister-tcl-lisp-command (tcl-interpreter-sap inter) name)
    handler))

(defmacro with-tcl-interpreter (inter (&amp;rest commands) &amp;body body)
  &quot;Evaluate the body in an environment were `inter' is bound to a
Tcl interpreter instance and for each (name tcl-proc) in `commands'
a Tcl command for name is defined, which invokes tcl-proc.&quot;
  `(let ((,inter (create-tcl-interpreter)))
     (unwind-protect
	  (progn
	    ,@(loop for (name handler) in commands
		    collect
		    `(register-tcl-command ,inter ,name ,handler))
	    ,@body)
       (destroy-tcl-interpreter ,inter))))

(defun eval-tcl-expr (inter expr)
  &quot;Evaluate the expression (string) `expr' in the Tcl-Interpreter
`inter' and return as multiple values the return code and result
string.&quot;
  (assert (tcl-interpreter-valid-p inter))
  (let* ((result-code (tcl-eval (tcl-interpreter-sap inter) expr))
	 (result-string (tcl-getstringresult (tcl-interpreter-sap inter))))
    (values result-code result-string)))

;;;; Lisp-side of the callback stuff.

(defun %lisp-callback-handler (inter-sap args)
  (handler-case
      (let ((inter (find inter-sap *tcl-interpreter-list*
			 :key #'tcl-interpreter-sap :test #'sap=)))
	(assert (and inter (tcl-interpreter-valid-p inter)))
	(let ((handler (gethash (car args)
				(tcl-interpreter-commands inter) nil)))
	  (assert handler)
	  (multiple-value-bind (code result)
	      (apply handler inter args)
	    (cons code result))))
    (error (c) (cons +TCL-ERROR+ (format nil &quot;Lisp error: ~A&quot; c)))))

(defun %update-lisp-callback-handler ()
  (set-lisp-callback-handler
   (kernel:get-lisp-obj-address #'%lisp-callback-handler)))

(defvar *lisp-callback-scavhook*
  (ext:make-scavenger-hook :value #'%lisp-callback-handler
			   :function #'%update-lisp-callback-handler))

(%update-lisp-callback-handler)
</pre>


<p> The following C code should be saved into a file
<tt>tcl-callback.c</tt>.

<pre class="code">
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;tcl.h&gt;
#include &quot;lisp.h&quot;
#include &quot;internals.h&quot;
#include &quot;alloc.h&quot;
#include &quot;arch.h&quot;

lispobj lisp_callback_handler;

static lispobj alloc_str_list(char *list[])
{
  lispobj result, newcons;
  struct cons *ptr;

  if (*list == NULL)
    result = NIL;
  else {
    result = newcons = alloc_cons(alloc_string(*list++), NIL);

    while (*list != NULL) {
      ptr = (struct cons *)PTR(newcons);
      newcons = alloc_cons(alloc_string(*list++), NIL);
      ptr->cdr = newcons;
    }
  }

  return result;
}

int LispTclProc(ClientData data,Tcl_Interp *interp,int argc,char** argv)
{
  lispobj lisp_result;
  struct vector *vec;
  char* result;
  int returnvalue;

  lisp_result=funcall2(lisp_callback_handler,alloc_sap(interp),
		       alloc_str_list(argv));

  returnvalue=fixnum_value(CONS(lisp_result)->car);
  vec=(struct vector*)PTR(CONS(lisp_result)->cdr);

  result=ckalloc((vec->length)+1);
  strcpy(result,(char*)vec->data);

  interp->result=result;
  interp->freeProc=TCL_DYNAMIC;

  return returnvalue;
}

void Set_Lisp_Callback_Handler(lispobj handler)
{
  lisp_callback_handler=handler;
}

void Register_Tcl_Lisp_Command(Tcl_Interp* interp,char* name)
{
  Tcl_CreateCommand(interp,name,LispTclProc,NULL,NULL);
}

void Unregister_Tcl_Lisp_Command(Tcl_Interp* interp,char* name)
{
  Tcl_DeleteCommand(interp,name);
}
</pre>


<p> Here is some code you can use to load the demo into CMUCL:
</p>

<pre class="code">
(alien:load-foreign &quot;/usr/lib/libtcl8.0.so&quot;)
(alien:load-foreign (make-pathname :name &quot;tcl-callback&quot; :type &quot;o&quot; :version nil
				   :defaults *load-truename*))
(load (compile-file (make-pathname :name &quot;cl-tcl&quot; :type &quot;cl&quot; :version nil
				   :defaults *load-truename*)))
</pre>


<p> And finally, here is some sample code demonstrating the use of a tcl
function which calls back into Lisp:

<pre class="code">
(cl:defpackage &quot;CL-TCL-DEMO&quot;
    (:use &quot;CL&quot; &quot;CL-TCL&quot;)
  (:export &quot;TCL-DEMO&quot;))

(in-package :CL-TCL-DEMO)

(defun tcl-incr (inter cmd first &amp;optional second)
  (declare (ignore inter cmd))
  (values 0
	  (format nil &quot;~D&quot;
		  (+ (parse-integer first)
		     (if second (parse-integer second) 1)))))

(defun tcl-demo (n)
  (with-tcl-interpreter inter ((&quot;lincr&quot; #'tcl-incr))
    (multiple-value-bind (code result)
	(eval-tcl-expr inter
		       (format nil &quot;set result \&quot;(\&quot;
for {set i 1} {$i &lt;= ~D} {set i [lincr $i 2]} {append result $i \&quot; \&quot;}
append result \&quot;)\&quot;
return $result&quot; n))
      (case code
	((#.+TCL-OK+ #.+TCL-RETURN+) (read-from-string result))
	(t (values code result))))))
</pre>

<p class=credits> This description is adapted from the article
<tt>&lt;87k8jzthta.fsf@orion.dent.isdn.cs.tu-berlin.de&gt;</tt> posted to
the USENET group comp.lang.lisp on 2000-02-21 by Pierre Mai. </p>

@@FOOTER@@
</body>
</html>
